import {ControlValueAccessor, NgModel, NG_VALUE_ACCESSOR, CORE_DIRECTIVES} from "angular2/common";
import {Component, ElementRef, Renderer, Input,Provider,forwardRef,ComponentRef,DynamicComponentLoader} from "angular2/core";
import * as moment from 'moment';
import { DOM } from 'angular2/src/platform/dom/dom_adapter';


export interface TimeSelectorConfig {
  format:string;
  showSeconds?:boolean;
  is24hourFormat?:boolean;
  hoursStep?:number;
  minutesStep?:number;
  secondsStep?:number;
  iconCls?:string;
}


enum TimeType{
  HOURS,
  MINUTES,
  SECONDS,
  PERIOD
}

const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = new Provider(
  NG_VALUE_ACCESSOR, {
    useExisting: forwardRef(() => TimeSelectorComponent),
    multi: true
  });

@Component({
  selector: 'timeselector',
  template : require('./time-selector.html'),
  directives: [CORE_DIRECTIVES],
  host: {
    '(change)': '_onChangeCallback($event.target.value)',
    '(blur)': '_onChangeCallback($event.target.value)',
    '(document:click)': 'onMouseDown($event)'
  },
  providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR,ElementRef,Renderer]
})
export class TimeSelectorComponent implements ControlValueAccessor {
    @Input()
    private class;

    @Input()
    private config:TimeSelectorConfig;

    private hours:string;
    private minutes:string;
    private seconds:string;
    private period:string;
    private optionsCmpRef : ComponentRef;
    private optionsTargetEl : ElementRef;
    private _value: string = '';

    constructor(private _loader:DynamicComponentLoader,
                private _elementRef:ElementRef,
                private _renderer: Renderer) {
    }

    //get accessor
    get value(): any { return this._value; };

    //set accessor including call the onchange callback
    set value(v: any) {
      if (v !== this._value) {
        this._value = v;
        this._onChangeCallback(v);
      }
    }

    private _onChangeCallback: (_:any) => void = () => {};
    private onTouched = () => {};

    buildValue(){
      if(this.hours == undefined){
        return;
      }
      let hrs:number = parseInt(this.hours);
      if(!this.config.is24hourFormat && this.period){
          if(this.period == 'AM'){
            hrs = (hrs == 12) ? 0 : hrs;
          }
          else{
            hrs = (hrs == 12) ? hrs : hrs+12;
          }
      }
      return moment().hours(hrs).minutes(this.minutes ? parseInt(this.minutes) : 0 ).
              seconds(this.seconds ? parseInt(this.seconds) : 0).format(this.config.format);
    }
    updateValue(){
      this.writeValue(this.buildValue());
      this._elementRef.nativeElement.dispatchEvent(new Event('change'));
    }
    writeValue(value: any): void {
      if(value){
        this.value = value;
        this.setFromDate();
        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', this.value);
      }
    }

    setFromDate(): void{
      let date = moment(this.value,this.config.format);
      this.hours = date.format(this.config.is24hourFormat? 'HH': 'hh');
      this.minutes = date.format('mm');
      this.period = !this.config.is24hourFormat ? date.format('A') : '';
      if(this.config.showSeconds){
        this.seconds = date.format('ss');
      }
    }

    registerOnChange(fn: any) {
      this._onChangeCallback = fn;
    }
    registerOnTouched(fn: () => any): void { this.onTouched = fn; }

    private getOptions(start:number,end:number,step:number): string[] {
      let options:string[]=[];
      for(let i=start; i<end ; i+=step){
        options.push(i < 10 ? "0"+i.toString() : i.toString());
      }
      return options;
    }
    onTriggerClicked(target:any,type:string){
      if(this.optionsCmpRef){
        this.closeOptions();
      }
      var self = this;
      let options:string[] = [],
          step:number,
          onSelectFn : Function;
          switch(TimeType[type]){
            case TimeType.HOURS :
              step = this.config.hoursStep ? this.config.hoursStep : 1;
              let end : number = this.config.is24hourFormat ? 24 : 13;
              let start : number = this.config.is24hourFormat ? 0 : 1;
              options= self.getOptions(start,end,step);
              onSelectFn = (selectedVal) =>{self.hours = selectedVal;self.updateValue();};
              break;
            case TimeType.MINUTES :
              step = this.config.minutesStep ? this.config.minutesStep : 5;
              options = self.getOptions(0,60,step);
              onSelectFn = (selectedVal) =>{self.minutes = selectedVal;self.updateValue();};
              break;
            case TimeType.SECONDS :
              step = this.config.secondsStep ? this.config.secondsStep : 5;
              options = self.getOptions(0,60,step);
              onSelectFn = (selectedVal) =>{self.seconds = selectedVal;self.updateValue();};
              break;
            case TimeType.PERIOD :
              options = ["AM","PM"];
              onSelectFn = (selectedVal) =>{self.period = selectedVal;self.updateValue();};
              break;
          }

      var boundingClientRect = target.getBoundingClientRect();
      this._loader.loadNextToLocation(TimeSelectorOptions,this._elementRef).then((compRef: ComponentRef) =>{
          // Using DOM unit Custom Render service is implemented https://github.com/angular/angular/issues/2409
          DOM.appendChild(DOM.query('body'), compRef.location.nativeElement);
          self.optionsTargetEl = target;
          self.optionsCmpRef = compRef;
          self.optionsCmpRef.instance.targetCls = 'time-selector-list-position-bottom';
          self.optionsCmpRef.instance.timeOptions = options;
          self.optionsCmpRef.instance.top = boundingClientRect.top + boundingClientRect.height;
          self.optionsCmpRef.instance.left = boundingClientRect.left;
          self.optionsCmpRef.instance.optionSelected = onSelectFn;
      });
    }

    onMouseDown(event : any){
      if ((event.target !== this.optionsTargetEl) && this.optionsCmpRef){
          this.closeOptions();
      }
    }

    closeOptions(){
      this.optionsCmpRef.dispose();
      this.optionsCmpRef = null;
    }

}


@Component({
  selector: 'options',
  providers: [ComponentRef],
  template : `<div class="time-selector" [ngClass]="targetCls" [ngStyle]="{'top':top+'px','left':left+'px'}"> <ul *ngIf="timeOptions">
                <li *ngFor="#option of timeOptions" (click)="optionSelected(option)">{{option}}</li>
              </ul></div>`,
  styles : [`
            .time-selector{
              z-index: 1001;
              background-clip: padding-box;
              display: block;
              position: absolute;
              font-size: 14px;
              text-align: left;
              background-color: #FFF;
              border: 1px solid rgba(0,0,0,.15);
              border-radius: 4px;
              margin-top : 5px;
              -webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);
            	-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);
            	box-shadow:0 5px 10px rgba(0,0,0,0.2);
            }

            ul{
                max-height: 72px;
                text-align: center;
                padding: 0;
                margin-top: 10px;
                min-width: 50px;
                overflow: auto;
              }
              .time-selector-list-position-bottom::before{
                content: "";
                display: inline-block;
                position: absolute;
                box-sizing: border-box;
                border-top: 0;
                top: -7px;
                border-bottom: 7px solid #999;
                border-left: 7px solid transparent;
                border-right: 7px solid transparent;
                left: 6px;
              }

              .time-selector-list-position-bottom::after{
                content: "";
                display: inline-block;
                position: absolute;
                box-sizing: border-box;
                border-top: 0;
                top: -6px;
                border-bottom: 6px solid #ffffff;
                left: 7px;
                border-left: 6px solid transparent;
                border-right: 6px solid transparent;
              }
              .time-selector-list-position-top::before{
                content: "";
                display: inline-block;
                position: absolute;
                box-sizing: border-box;
                border-top: 0;
                bottom: -7px;
                border-top: 7px solid #999;
                border-left: 7px solid transparent;
                border-right: 7px solid transparent;
                left: 6px;
              }

              .time-selector-list-position-top::after{
                content: "";
                display: inline-block;
                position: absolute;
                box-sizing: border-box;
                border-top: 0;
                bottom: -6px;
                border-top: 6px solid #ffffff;
                left: 7px;
                border-left: 6px solid transparent;
                border-right: 6px solid transparent;
              }

              li:hover{
                background: #1980EC;
                color: #fff;
                cursor: pointer;
              }`]
})
export class TimeSelectorOptions{
  private _timeOptions:string[]=[];
  private _top:number;
  private _left:number;
  private _targetCls : string;

  public optionSelected: (value:string) => void = () => {};

  set timeOptions(timeOptions:string[]){
    this._timeOptions = timeOptions;
  }

  get timeOptions(){
    return this._timeOptions;
  }


  set top(top:number){
    this._top = top;
  }

  get top(){
    return this._top;
  }

  set left(left:number){
    this._left = left;
  }

  get left(){
    return this._left;
  }

  set targetCls(targetCls:string){
    this._targetCls = targetCls;
  }

  get targetCls(){
    return this._targetCls;
  }

}
